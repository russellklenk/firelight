package com.ninjabird.firelight.renderer.atlas
{
    import com.ninjabird.firelight.debug.DebugTrace;
    import com.ninjabird.firelight.renderer.events.ContextLostEvent;
    import com.ninjabird.firelight.renderer.events.ContextReadyEvent;
    import com.ninjabird.firelight.renderer.events.RenderEvents;
    import com.ninjabird.firelight.renderer.DisplayContext;
    import com.ninjabird.firelight.renderer.ResourcePool;
    import com.ninjabird.firelight.renderer.TextureDesc;

    import flash.display.Bitmap;
    import flash.display.BitmapData;
    import flash.display.MovieClip;
    import flash.display.Shape;
    import flash.display.Sprite;
    import flash.display3D.Context3DTextureFormat;
    import flash.display3D.textures.Texture;

    /**
     * Maintains a list of texture pages, dynamically constructed from images,
     * vector shapes or animations generated by the application. Images are
     * dynamically packed into a texture atlas.
     */
    public final class ImageCache
    {
        /**
         * The default width of a texture page, in pixels.
         */
        public static const DEFAULT_PAGE_WIDTH:int  = 2048;

        /**
         * The default height of a texture page, in pixels.
         */
        public static const DEFAULT_PAGE_HEIGHT:int = 2048;

        /**
         * The AtlasBuilder used to construct texture pages.
         */
        public var pageBuilder:AtlasBuilder;

        /**
         * The list of atlas entries for the page under construction.
         */
        public var pageEntries:Vector.<AtlasEntry>;

        /**
         * The name of the group identifying the page table.
         */
        public var groupName:String;

        /**
         * The width of the texture page being constructed, in pixels.
         */
        public var textureWidth:int;

        /**
         * The height of the texture page being constructed, in pixels.
         */
        public var textureHeight:int;

        /**
         * The 32-bit ABGR background color of the page being constructed.
         */
        public var backgroundColor:uint;

        /**
         * The vertical padding between items on a texture page, in pixels.
         */
        public var verticalPad:int;

        /**
         * The horizontal padding between items on a texture page, in pixels.
         */
        public var horizontalPad:int;

        /**
         * The resource pool in which all textures are created.
         */
        public var resourcePool:ResourcePool;

        /**
         * The list of all AtlasEntry objects, in the order they were added to
         * the page table.
         */
        public var entryList:Vector.<AtlasEntry>;

        /**
         * A table mapping application-defined entry name to the corresponding
         * AtlasEntry instance.
         */
        public var entriesByName:Object;

        /**
         * The list of texture pages defined in this page table.
         */
        public var pageList:Vector.<TextureDesc>;

        /**
         * Callback invoked when the rendering context is lost.
         * @param ev Additional information about the event.
         */
        private function handleContextLost(ev:ContextLostEvent) : void
        {
            /* empty */
        }

        /**
         * Callback invoked when the rendering context is restored.
         * @param ev Additional information about the event.
         */
        private function handleContextReady(ev:ContextReadyEvent) : void
        {
            if (this.resourcePool) this.prepareGpuResources();
        }

        /**
         * Constructs a new instance with no pages defined.
         * @param group The name of the cache, used for debugging purposes.
         */
        public function ImageCache(group:String)
        {
            if (group)
            {
                this.pageBuilder     = new AtlasBuilder();
                this.pageEntries     = new Vector.<AtlasEntry>();
                this.groupName       = group;
                this.textureWidth    = ImageCache.DEFAULT_PAGE_WIDTH;
                this.textureHeight   = ImageCache.DEFAULT_PAGE_HEIGHT;
                this.backgroundColor = 0x00000000;
                this.verticalPad     = 0;
                this.horizontalPad   = 0;
                this.resourcePool    = null;
                this.entryList       = new Vector.<AtlasEntry>();
                this.entriesByName   = new Object();
                this.pageList        = new Vector.<TextureDesc>();
            }
            else
            {
                DebugTrace.out('ImageCache::ctor(1) - No group name specified.');
                throw new ArgumentError('group');
            }
        }

        /**
         * Specifies the resource pool in which GPU resources will be created
         * and initializes the atlas builder using the current texture
         * dimensions and background color.
         * @param pool The resource pool in which all GPU resources will be
         * created.
         * @return true if the resource pool was attached successfully.
         */
        public function attachResourcePool(pool:ResourcePool) : Boolean
        {
            var dc:DisplayContext = pool.displayContext;
            if (dc)
            {
                this.resourcePool = pool;
                if (this.pageBuilder)
                {
                    this.pageBuilder.clearAtlas(
                        this.textureWidth,
                        this.textureHeight,
                        this.backgroundColor,
                        this.horizontalPad,
                        this.verticalPad);
                }
                dc.addEventListener(RenderEvents.CONTEXT_LOST, this.handleContextLost);
                dc.addEventListener(RenderEvents.CONTEXT_READY, this.handleContextReady);
                return true;
            }
            else
            {
                DebugTrace.out('ImageCache[%s]::attachResourcePool(1) - Invalid display context.', this.groupName);
                return false;
            }
        }

        /**
         * Prepares GPU resources for use during recovery from a lost context.
         * @return true if all the image cache recovered successfully.
         */
        public function prepareGpuResources() : Boolean
        {
            // if we had any texture pages before the context loss, free them.
            // the application will have to re-load/upload the content anyway.
            // we could attempt to re-upload everything for the application,
            // but that significantly limits freedom to manage memory, because
            // it doesn't allow the application to unload CPU content after it
            // has been uploaded to the GPU, potentially doubling memory usage.
            if (this.pageList.length > 0 && this.resourcePool !== null)
            {
                var pool:ResourcePool          = this.resourcePool;
                var pages:Vector.<TextureDesc> = this.pageList;
                for (var i:int = 0, n:int = pages.length; i < n; ++i)
                {
                    pool.disposeTexture(pages[i]);
                    pages[i] = null;
                }
            }
            if (this.pageBuilder)
            {
                this.pageBuilder.dispose();
                this.pageBuilder = null;
            }

            // now, re-create everything that the application will need to
            // upload data into the image cache, as if it were empty.
            this.pageBuilder   = new AtlasBuilder();
            this.pageEntries   = new Vector.<AtlasEntry>();
            this.entryList     = new Vector.<AtlasEntry>();
            this.entriesByName = new Object();
            this.pageList      = new Vector.<TextureDesc>();
            if (this.resourcePool)
            {
                // initialize the new atlas builder with the saved attributes.
                this.pageBuilder.clearAtlas(this.textureWidth, this.textureHeight, this.backgroundColor, this.horizontalPad, this.verticalPad);
            }
            return true;
        }

        /**
         * Disposes of all texture objects owned by the page table.
         * @return The ResourcePool previously attached to the page table.
         */
        public function disposeGpuResources() : ResourcePool
        {
            if (this.resourcePool)
            {
                var pool:ResourcePool = this.resourcePool;
                var dc:DisplayContext = pool.displayContext;
                if (dc)
                {
                    dc.removeEventListener(RenderEvents.CONTEXT_LOST, this.handleContextLost);
                    dc.removeEventListener(RenderEvents.CONTEXT_READY, this.handleContextReady);
                }
                for (var i:int = 0; i < this.pageList.length; ++i)
                {
                    pool.disposeTexture(this.pageList[i]);
                    this.pageList[i]  = null;
                }
                if (this.pageBuilder)
                {
                    this.pageBuilder.dispose();
                    this.pageBuilder  = null;
                }
                this.resourcePool       = null;
                this.pageEntries.length = 0;
                this.entryList.length   = 0;
                this.entriesByName      = new Object();
                return pool;
            }
            else return null;
        }

        /**
         * Adds a BitmapData to the current texture page.
         * @param name The application-defined name associated with the image.
         * @param data The source image data.
         * @return The descriptor for the item, or null.
         */
        public function addBitmapData(name:String, data:BitmapData) : AtlasEntry
        {
            var entry:AtlasEntry = this.entriesByName[name];
            if (entry)
            {
                DebugTrace.out('ImageCache[%s]::addBitmapData(2) - Duplicate name %s; Ignoring.', this.groupName, name);
                return entry;
            }

            var node:PackerNode  = this.pageBuilder.addBitmapData(data);
            if (node)
            {
                // this item was successfully added to the current page.
                entry = new AtlasEntry(name);
                entry.addFrame(node.contentX, node.contentY, node.contentWidth, node.contentHeight, this.pageList.length);
                this.pageEntries.push(entry);
                return entry;
            }
            else
            {
                // this page is full; flush and try again.
                this.flushPage();
                return this.addBitmapData(name, data);
            }
        }

        /**
         * Adds a flash.display.Bitmap to the current texture page.
         * @param name The application-defined name associated with the image.
         * @param bitmap The flash.display.Bitmap content to add.
         * @param useVector true to rasterize the content using the vector
         * renderer. The vector renderer is slower, but supports transforms.
         * @return The descriptor for the item, or null.
         */
        public function addBitmap(name:String, bitmap:Bitmap, useVector:Boolean=false) : AtlasEntry
        {
            if (useVector === false)
            {
                // add the item as BitmapData instead.
                return this.addBitmapData(name, bitmap.bitmapData);
            }
            // otherwise, we always add using the vector renderer.
            var entry:AtlasEntry = this.entriesByName[name];
            if (entry)
            {
                DebugTrace.out('ImageCache[%s]::addBitmap(3) - Duplicate name %s; Ignoring.', this.groupName, name);
                return entry;
            }

            var node:PackerNode  = this.pageBuilder.addBitmap(bitmap, useVector);
            if (node)
            {
                // this item was successfully added to the current page.
                entry = new AtlasEntry(name);
                entry.addFrame(node.contentX, node.contentY, node.contentWidth, node.contentHeight, this.pageList.length);
                this.pageEntries.push(entry);
                return entry;
            }
            else
            {
                // this page is full; flush and try again.
                this.flushPage();
                return this.addBitmap(name, bitmap, useVector);
            }
        }

        /**
         * Adds a specific frame of a MovieClip to the current texture page.
         * @param name The application-defined name associated with the movie.
         * @param movie The flash.display.MovieClip representing the animation.
         * @param frame The zero-based index of the frame to rasterize.
         * @param entry The parent entry for the movie, or null.
         * @return The descriptor for the item, or null.
         */
        public function addMovieFrame(name:String, movie:MovieClip, frame:int, entry:AtlasEntry=null) : AtlasEntry
        {
            if (entry)
            {
                var node:PackerNode = this.pageBuilder.addMovieFrame(movie, frame);
                if (node)
                {
                    // this item was successfully added to the current page.
                    entry.addFrame(node.contentX, node.contentY, node.contentWidth, node.contentHeight, this.pageList.length);
                    // note that we don't add this item to the pageEntries list.
                    // this entry is managed externally.
                    return entry;
                }
                else
                {
                    // this page is full; flush and try again.
                    this.flushPage();
                    return this.addMovieFrame(name, movie, frame, entry);
                }
            }
            else
            {
                // this frame is being added as a unique item, not as part of
                // a parent movie clip, so create and add the entry here.
                entry = this.entriesByName[name];
                if (entry)
                {
                    DebugTrace.out('ImageCache[%s]::addMovieFrame(4) - Duplicate name %s; Ignoring.', this.groupName, name);
                    return entry;
                }
                entry = new AtlasEntry(name);
                if (this.addMovieFrame(name, movie, frame, entry))
                {
                    this.pageEntries.push(entry);
                    return entry;
                }
                else return null;
            }
        }

        /**
         * Adds an animation represented by a flash.display.MovieClip to the current texture page.
         * @param name The application-defined name associated with the movie.
         * @param movie The flash.display.MovieClip representing the animation.
         * @return The descriptor for the item, or null.
         */
        public function addMovie(name:String, movie:MovieClip) : AtlasEntry
        {
            var entry:AtlasEntry = this.entriesByName[name];
            if (entry)
            {
                DebugTrace.out('ImageCache[%s]::addMovie(2) - Duplicate name %s; Ignoring.', this.groupName, name);
                return entry;
            }

            entry = new AtlasEntry(name);
            this.pageEntries.push(entry);
            for (var i:int = 0; i < movie.totalFrames; ++i)
            {
                if (this.addMovieFrame(name, movie, i, entry) === null)
                {
                    // this frame could not be added, so fail.
                    if (this.pageEntries.length > 0)
                    {
                        // no flush of the current page has occurred.
                        this.pageEntries.pop();
                    }
                    else
                    {
                        // the current page was flushed, so our entry
                        // got pushed to the main entryList/entriesByName.
                        delete this.entriesByName[name];
                        this.entryList.pop();
                    }
                    return null;
                }
            }
            return entry;
        }

        /**
         * Adds a flash.display.Shape to the current texture page.
         * @param name The application-defined name associated with the image.
         * @param shape The flash.display.Shape content to add.
         * @return The descriptor for the item, or null.
         */
        public function addShape(name:String, shape:Shape) : AtlasEntry
        {
            var entry:AtlasEntry = this.entriesByName[name];
            if (entry)
            {
                DebugTrace.out('ImageCache[%s]::addShape(2) - Duplicate name %s; Ignoring.', this.groupName, name);
                return entry;
            }

            var node:PackerNode  = this.pageBuilder.addShape(shape);
            if (node)
            {
                // this item was successfully added to the current page.
                entry = new AtlasEntry(name);
                entry.addFrame(node.contentX, node.contentY, node.contentWidth, node.contentHeight, this.pageList.length);
                this.pageEntries.push(entry);
                return entry;
            }
            else
            {
                // this page is full; flush and try again.
                this.flushPage();
                return this.addShape(name, shape);
            }
        }

        /**
         * Adds a flash.display.Sprite to the current texture page.
         * @param name The application-defined name associated with the image.
         * @param sprite The flash.display.Sprite content to add.
         * @return The descriptor for the item, or null.
         */
        public function addSprite(name:String, sprite:Sprite) : AtlasEntry
        {
            var entry:AtlasEntry = this.entriesByName[name];
            if (entry)
            {
                DebugTrace.out('ImageCache[%s]::addSprite(2) - Duplicate name %s; Ignoring.', this.groupName, name);
                return entry;
            }

            var node:PackerNode  = this.pageBuilder.addSprite(sprite);
            if (node)
            {
                // this item was successfully added to the current page.
                entry = new AtlasEntry(name);
                entry.addFrame(node.contentX, node.contentY, node.contentWidth, node.contentHeight, this.pageList.length);
                this.pageEntries.push(entry);
                return entry;
            }
            else
            {
                // this page is full; flush and try again.
                this.flushPage();
                return this.addSprite(name, sprite);
            }
        }

        /**
         * Explicitly flushes the current data to a texture page. This blocks
         * the calling thread until the texture upload has completed, and
         * resets the atlas builder in preparation for a new page.
         */
        public function flushPage() : void
        {
            var pool:ResourcePool    = this.resourcePool;
            var builder:AtlasBuilder = this.pageBuilder;
            if (builder.imageCount > 0)
            {
                var pageId:int       = this.pageList.length;
                var page:TextureDesc = pool.createTexture(this.textureWidth, this.textureHeight, Context3DTextureFormat.BGRA);
                var texture:Texture  = pool.textureFor(page) as Texture;
                if (texture)
                {
                    // upload the texture data.
                    texture.uploadFromBitmapData(builder.bitmap);

                    // add the page to the page list.
                    this.pageList[pageId] = page;

                    // add the entries to the entry list.
                    var entryCount:int    = this.entryList.length;
                    for (var i:int = 0; i < this.pageEntries.length; ++i)
                    {
                        var e:AtlasEntry  = this.pageEntries[i];
                        this.entryList[entryCount++] = e;
                        this.entriesByName[e.name]   = e;
                    }
                }
                // now clear the atlas builder and any intermediate lists.
                this.pageEntries.length = 0;
                builder.clearAtlas(this.textureWidth, this.textureHeight, this.backgroundColor, this.horizontalPad, this.verticalPad);
            }
        }

        /**
         * Indicates that no more images will be uploaded to the cache. This
         * will dispose of the underlying AtlasBuilder, freeing up a significant
         * amount of memory, after first flushing any pending data to the GPU.
         */
        public function finalize() : void
        {
            if (this.pageBuilder)
            {
                this.flushPage();
                this.pageBuilder.dispose();
                this.pageBuilder = null;
            }
        }

        /**
         * Disposes of all resources associated with this instance and detaches
         * from the GPU resource pool.
         */
        public function dispose() : void
        {
            this.disposeGpuResources();
            this.pageBuilder     = null;
            this.pageEntries     = null;
            this.groupName       = null;
            this.textureWidth    = ImageCache.DEFAULT_PAGE_WIDTH;
            this.textureHeight   = ImageCache.DEFAULT_PAGE_HEIGHT;
            this.backgroundColor = 0x00000000;
            this.verticalPad     = 0;
            this.horizontalPad   = 0;
            this.resourcePool    = null;
            this.entryList       = null;
            this.entriesByName   = null;
            this.pageList        = null;
        }
    }
}
